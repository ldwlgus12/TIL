# # 시간 복잡도 및 리스트

### # `시간복잡도`(Time Complexity)
- 계산 복잡도 이론에서 시간 복잡도는 `문제를 해결하는데 걸리는 시간`과 `입력의 함수 관계`를 가리킴.
- 단순하게 `알고리즘의 수행 시간`을 의미한다고
    - 시간 복잡도가 높다 -> 느린 알고리즘
    - 시간 복잡도가 낮다 -> 빠른 알고리즘

### # `빅오(Big-O)표기법`
- 입력 n이 `무한대`로 커진다고 가정하고 시간 복잡도를 간단하게 표시하는 것
- `최고차항`만 남기고 계수와 상수 제거
- `O(1)` : 단순 산술 계산(덧셈, 뺄셈, 곱셈, 나눗셈)
- `O(logN)` : 크기 N인 리스트를 반절씩 순회/탐색 (이진탐색, 분할정복)
 - `O(N)` : 크기 N인 리스트를 순회(리스트 순회, 1중 for문)
- `O(N log N)` : 크기 N인 리스트를 반절씩 탐색*순회 (높은 성능의 정렬)
- `O(N^2)` : 크기 M,N인 2중 리스트를 순회 (2중 리스트 순회, 2중 for문)
- `O(N^3)` : 3중 리스트를 순회 (3중 리스트 순회, 3중 for문)
- `O(2^N)` : 크기 N 집합의 부분 집합 (크기가 N인 집합의 부분 집합)
- `O(N!)` : 크기 N인 리스트의 순열

---------------------------------------------

## # 리스트

### # 배열(Array)
- `여러 데이터들이 연속된 메모리 공간에 저장되어 있는 자료구조`
    - 인덱스(index)를 통해 데이터에 빠르게 접근
    - 배열의 길이는 변경 불가 -> 길이를 변경하고 싶다면 새로 생성
    - 데이터 타입은 고정

### # 연결 리스트(Linked List)
- `데이터가 담긴 여러 노드들이 순차적으로 연결된 형태의 자료구조`
    - 맨 처음 노드부터 순차적으로 탐색
    - 연결리스트의 길이 자유롭게 변경 가능 -> 삽입, 삭제가 편리
    - 다양한 데이터 타입 저장
    - 데이터가 메모리에 연속적으로 저장되지 않음


### # 파이썬의 리스트
- 파이썬의 메서드
    - `.append()` : 리스트 맨 끝에 새로운 원소 `삽입`
    - `.pop()` : 특정 인덱스에 있는 원소를 `삭제 및 반환`
    - `.count()` : 리스트에서 해당 원소의 `개수`를 반환
    - `.index()` : 리스트에서 처음으로 원소가 등장하는 `인덱스` 반환
    - `.sort()` : 리스트를 오름차순으로 `정렬` / `reverse=True` 옵션을 통해 내림차순으로 정렬 가능
    - `.reverse()` : 리스트의 원소들의 순서를 거꾸로 `뒤집기`

- 리스트 관련 내장함수
    - `len()` : 리스트의 `길이`(원소의 개수)를 반환
    - `sum()` : 리스트의 모든 원소의 `합`을 반환
    - `max()` : 리스트의 원소 중 `최대값`을 반환
    - `min()` : 리스트의 원소 중 `최소값`을 반환
    - `sorted()` : 오름차순으로 `정렬`된 새로운 리스트 반환 / 원본 리스트는 변화 없음
    - `reversed()` : 리스트의 순서를 거꾸로 `뒤집은` 새로운 객체 반환 / 원본 리스트는 변화 없음

### # 리스트 컴프리헨션(List Comprehension)
- 리스트를 생성하는 간단한 방법
```
number = []
for i in range(5):
    number.append(i)

    ↓

number = [i for i in range(5)]

---------------------------
# if문으로 필터링도 가능

number = [i for i in range(10) if i % 2 == 1]
```